# 设计模式学习

## 1. 创造型模式

### 1.1 简单工厂模式

#### 1.1.1 模式定义
简单工厂模式,根据不同的参数，返回不同类的实例。
单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
### 1.1.2 模式结构
简单工厂分为3个角色:
 * Factory:负责实现创建所有实例的内部逻辑
 * Product:抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
 * ConcreteProduct:具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
### 1.1.3 模式分析
 * 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
 * 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。
 * 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，需要修改工厂的源码，这一点与开闭原则是相违背的。
 * 简单工厂模式的优点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

### 1.1.4 优点

* 工厂含有必要的判断逻辑，可以决定在什么条件下创建什么什么产品的实例，客户端可以免除创建对象的责任，仅仅使用产品对象；
* 客户端不需要知道所创建的具体产品类的名，只需要具体产品需要传入工厂的参数即可；
* 引入配置文件，如xml配置文件，可以不修改客户端代码，直接更换产品和增加新的具体产品类，在一定程度上提供系统的灵活性。

#### 1.1.5 缺点

* 简单工厂模式严重依赖工厂类，工厂类集成所有的产品创建，一旦工厂类不能正常工作，整个系统都要受到影响；
* 简单工厂模式会增加系统中类的个数，在一定程度上增加系统的复杂度和理解难度；
* 系统扩展难，如果添加新产品，就需要修改工厂逻辑，如果产品类型多，工厂生成产品过于复杂，不利于维护；
* 简单工厂模式使用了静态工厂方法，造成工厂角色无法形成于基于继承的等级结构。

#### 1.1.6 使用环境

* 工厂负责创建的对象较少：因为需要工厂创建的对象少，所以生成产品的方法逻辑就不会很复杂；
* 客户端只需要知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，也不需要知道创建的类名，只需要知道类型对应的参数。