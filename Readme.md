# 设计模式学习

## 1. 创造型模式

### 1.1 简单工厂模式

#### 1.1.1 模式定义
简单工厂模式,根据不同的参数，返回不同类的实例。
单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
### 1.1.2 模式结构
简单工厂分为3个角色:
 * Factory:负责实现创建所有实例的内部逻辑
 * Product:抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
 * ConcreteProduct:具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
### 1.1.3 模式分析
 * 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
 * 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。
 * 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，需要修改工厂的源码，这一点与开闭原则是相违背的。
 * 简单工厂模式的优点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

### 1.1.4 优点

* 工厂含有必要的判断逻辑，可以决定在什么条件下创建什么什么产品的实例，客户端可以免除创建对象的责任，仅仅使用产品对象；
* 客户端不需要知道所创建的具体产品类的名，只需要具体产品需要传入工厂的参数即可；
* 引入配置文件，如xml配置文件，可以不修改客户端代码，直接更换产品和增加新的具体产品类，在一定程度上提供系统的灵活性。

#### 1.1.5 缺点

* 简单工厂模式严重依赖工厂类，工厂类集成所有的产品创建，一旦工厂类不能正常工作，整个系统都要受到影响；
* 简单工厂模式会增加系统中类的个数，在一定程度上增加系统的复杂度和理解难度；
* 系统扩展难，如果添加新产品，就需要修改工厂逻辑，如果产品类型多，工厂生成产品过于复杂，不利于维护；
* 简单工厂模式使用了静态工厂方法，造成工厂角色无法形成于基于继承的等级结构。

#### 1.1.6 使用环境

* 工厂负责创建的对象较少：因为需要工厂创建的对象少，所以生成产品的方法逻辑就不会很复杂；
* 客户端只需要知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，也不需要知道创建的类名，只需要知道类型对应的参数。

### 1.2 工厂方法模式

#### 1.2.1 模式定义

工厂方法模式，把对产品对象的创建过程封装在工厂接口中的方法，将对象的创建和使用完全解耦。详细说就是，工厂方法模式规定一个顶级工厂接口和多个具体的工厂实现类，每个具体的工厂类都实现了工厂接口，负责创建一类具体产品。产品的顶级也是抽象的一个接口，具体产品也是实现产品接口的方法。

#### 1.2.2  模式结构

工厂方法模式的角色如下：

* 抽象产品
* 具体产品
* 抽象工厂
* 具体工厂

#### 1.2.3 模式分析

工厂方法模式是简单工厂模式的进一步推广和抽象，使用了面向对象的多态。在工厂方法模式中，顶级工厂接口不再负责所有产品的创建，而是把具体创建的工作交给其子类实现类去做。核心工厂仅需要在接口中规定方法，不需要去负责产品类呗实例化的细节，可以在不修改工厂角色的情况下添加新产品，添加实现类即可。

#### 1.2.4 优点

* 客户只用知道生产对应产品的工厂，不需要知道创建细节，也不需要知道具体的类名；
* 工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。多态体现在所有的工厂类都有同一抽象父类；
* 添加新产品无需修改抽象工厂和抽象产品接口，只需要添加具体实现工厂和实现产品即可。增强系统的扩展性，符合“开闭原则”。

#### 1.2.5 缺点

* 添加新产品的时候，需要编写新的具体产品类，还要提供具体的工厂类，系统中类增加，一定程度上增加了系统复杂度，会给系统带来额外开销；（个人认为这个缺点问题不大）
* 系统的可扩展性是引入抽象层带来的，客户端代码需要使用抽象层定义，增加了系统的抽象性和理解难度，实现时可能需要反射等技术，增加了系统实现难度。

#### 1.2.6 使用场景

* 一个类不知道它所需要的对象的类：客户端只需要知道具体的产品由哪个工厂生产即可；
* 一个类通过其子类来指定创建哪个对象: 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
* 创建对象的任务委托给多个工厂类中的某一个，客户端使用时可以无须关心是哪一个工厂子类的创建产品子类，可以动态指定，例如把具体工厂的类名存入数据库或者配置文件，到使用时使用反射来获取加载。