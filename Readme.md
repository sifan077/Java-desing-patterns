# 设计模式学习

## 1. 创造型模式

### 1.1 简单工厂模式

#### 1.1.1 模式定义
简单工厂模式,根据不同的参数，返回不同类的实例。
单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
#### 1.1.2 模式结构
简单工厂分为3个角色:
 * Factory:负责实现创建所有实例的内部逻辑
 * Product:抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
 * ConcreteProduct:具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
#### 1.1.3 模式分析
 * 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
 * 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。
 * 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，需要修改工厂的源码，这一点与开闭原则是相违背的。
 * 简单工厂模式的优点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

#### 1.1.4 优点

* 工厂含有必要的判断逻辑，可以决定在什么条件下创建什么什么产品的实例，客户端可以免除创建对象的责任，仅仅使用产品对象；
* 客户端不需要知道所创建的具体产品类的名，只需要具体产品需要传入工厂的参数即可；
* 引入配置文件，如xml配置文件，可以不修改客户端代码，直接更换产品和增加新的具体产品类，在一定程度上提供系统的灵活性。

#### 1.1.5 缺点

* 简单工厂模式严重依赖工厂类，工厂类集成所有的产品创建，一旦工厂类不能正常工作，整个系统都要受到影响；
* 简单工厂模式会增加系统中类的个数，在一定程度上增加系统的复杂度和理解难度；
* 系统扩展难，如果添加新产品，就需要修改工厂逻辑，如果产品类型多，工厂生成产品过于复杂，不利于维护；
* 简单工厂模式使用了静态工厂方法，造成工厂角色无法形成于基于继承的等级结构。

#### 1.1.6 使用环境

* 工厂负责创建的对象较少：因为需要工厂创建的对象少，所以生成产品的方法逻辑就不会很复杂；
* 客户端只需要知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，也不需要知道创建的类名，只需要知道类型对应的参数。

### 1.2 工厂方法模式

#### 1.2.1 模式定义

工厂方法模式，把对产品对象的创建过程封装在工厂接口中的方法，将对象的创建和使用完全解耦。详细说就是，工厂方法模式规定一个顶级工厂接口和多个具体的工厂实现类，每个具体的工厂类都实现了工厂接口，负责创建一类具体产品。产品的顶级也是抽象的一个接口，具体产品也是实现产品接口的方法。

#### 1.2.2  模式结构

工厂方法模式的角色如下：

* 抽象产品
* 具体产品
* 抽象工厂
* 具体工厂

#### 1.2.3 模式分析

工厂方法模式是简单工厂模式的进一步推广和抽象，使用了面向对象的多态。在工厂方法模式中，顶级工厂接口不再负责所有产品的创建，而是把具体创建的工作交给其子类实现类去做。核心工厂仅需要在接口中规定方法，不需要去负责产品类被实例化的细节，可以在不修改工厂角色的情况下添加新产品，添加实现类即可。

#### 1.2.4 优点

* 客户只用知道生产对应产品的工厂，不需要知道创建细节，也不需要知道具体的类名；
* 工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。多态体现在所有的工厂类都有同一抽象父类；
* 添加新产品无需修改抽象工厂和抽象产品接口，只需要添加具体实现工厂和实现产品即可。增强系统的扩展性，符合“开闭原则”。

#### 1.2.5 缺点

* 添加新产品的时候，需要编写新的具体产品类，还要提供具体的工厂类，系统中类增加，一定程度上增加了系统复杂度，会给系统带来额外开销；（个人认为这个缺点问题不大）
* 系统的可扩展性是引入抽象层带来的，客户端代码需要使用抽象层定义，增加了系统的抽象性和理解难度，实现时可能需要反射等技术，增加了系统实现难度。

#### 1.2.6 使用场景

* 一个类不知道它所需要的对象的类：客户端只需要知道具体的产品由哪个工厂生产即可；
* 一个类通过其子类来指定创建哪个对象: 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
* 创建对象的任务委托给多个工厂类中的某一个，客户端使用时可以无须关心是哪一个工厂子类的创建产品子类，可以动态指定，例如把具体工厂的类名存入数据库或者配置文件，到使用时使用反射来获取加载。

### 1.3 抽象工厂模式

#### 1.3.1 模式定义

提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

#### 1.3.2 模式结构

抽象工厂模式的角色如下:

* 抽象工厂
* 具体工厂
* 抽象产品
* 具体产品

#### 1.3.3 模式分析

该模式中有一个抽象工厂接口，声明了一组创建抽象产品的方法。具体工厂实现该接口并创建特定的产品。每个具体工厂创建一组相关产品。

#### 1.3.4 优点

* 抽象工厂模式隔离了具体类的生成，客户不知道具体的对象是怎么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。
* 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
* 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。

#### 1.3.5 缺点

* 如果要添加新种类产品，就需要修改顶级抽象工厂，那么所以实现抽象工厂的类都需要进行修改，很明显会非常不便。
* 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

#### 1.3.6 使用场景

* 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
* 系统中有多个产品族，每次必须使用其中的一个产品族。
* 同一产品族的产品需要在一起使用。
* 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

### 1.4 建造者模式

#### 1.4.1 模式定义

将一个复杂对象的构建与其表示抽离，使得同样的构建过程可以创建不同的表示。

#### 1.4.2 模式结构

* 抽象建造者
* 具体建造者
* 指挥者
* 产品

#### 1.4.3 模式分析

抽象者建造类定义了产品的建造和返回方法。

建造者模式引入了一个指挥者的角色，这个类的作用是：一方面隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道建造者的类型，通过指挥者调用相关方法，即可得到产品对象。

客户端不需要关心产品对象的组装，只需要确定具体建造者的类型即可。建造者将复杂对象的构建与对象的表现分离，这样使得同样的构建过程创建出不同的的表现。

#### 1.4.4 优点

* 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
* 具体建造者都相对独立，而与其他的具体建造者无关，因此方便替换j具体的建造者或者增加新的具体建造者。用户使用不同的具体建造者可以得到不同的产品对象。
* 可以精准的控制产品的创建过程。
* 增加新的具体建造者不用修改原来的系统代码，指挥者面对接口编程，系统扩展方便。

#### 1.4.5 缺点

* 如果产品差异较大，则不适用于使用建造者模式。
* 如果产品内部复杂，可能导致需要很多具体建造者类来实现这种变化，导致系统很大。

#### 1.4.6 使用场景

* 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
* 需要生产的产品的属性相互依赖，需要指定顺序。
* 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥类，将创建过程封装在指挥类中，而不是具体建造者类。
* 隔离负责对象的创建和应用，使得相同的创建过程可以创建不同的产品对象。

### 1.5 单例模式

#### 1.5.1 模式定义

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式要点：

1. 某个类只能有一个实例；
2. 它必须自己创建这个实例；
3. 它必须向整个系统提供访问这个实例的方法。

#### 1.5.2 模式结构

* 单例

#### 1.5.3 模式分析

单例模式目的是保证一个类仅有一个实例，并提供一个全局访问点。单例模式包含的角色只有一个，也就是单体类，单体类的构造函数私有，确保无法构造对象。提供一个静态方法负责检验和创建返回单例。

要点如下:

* 单例类的构造函数私有；
* 提供一个自身静态私有成员变量；
* 提供一个公有的静态工厂方法。

#### 1.5.4 优点

* 提供了对唯一实例的受控访问。严格控制客户在什么时候可以访问它。
* 在系统内存内只有一个对象，避免去频繁的创建和销毁，节省性能。
* 允许可变数目的实例。我们可以使用单例模式进行扩展，可以使用单例控制相似的方法获取指定个数的对象。

#### 1.5.5 缺点

* 单体类没有抽象，很难扩展；
* 单体类的职责过重，违反`单一职责原则`；
* 滥用单例带来负面问题，为了节省资源将数据库连接池设为单例，导致共享连接池对象过多，导致连接池溢出。对于有自动回收垃圾的语言来说，如果对象实例化后长久未使用，可能会被回收，自动销毁，下次使用时创建，会导致对象状态丢失。

#### 1.5.6 使用场景

* 系统只需要一个实例对象，例如提供一个唯一的序号生成器，或者资源开销很大的对象；
* 客户调用类的单个实例只允许使用一个公共访问点，除了访问该公共点，无法通过其他方法访问该实例；
* 一个系统要求一个类有一个实例才使用单例模式，反之则使用多例模式。

## 2. 结构型模式

### 2.1 适配器模式

#### 2.1.1 模式定义

将一个接口转换为客户希望的另一个接口，适配器模式使接口不兼容的那些类一起工作。可分为类适配器和对象适配器。

#### 2.1.2 模式结构

* 目标抽象接口
* 适配器类
* 适配者类
* 客户类

#### 2.1.3 模式分析

适配器模式包含三个主要组件：

1. 客户端所期望的接口。它定义了客户端使用的方法和属性，但是并不实现这些方法和属性。
2. 需要被适配的接口。它定义了不兼容的方法和属性，需要被转换为目标接口。
3. 连接目标接口和源接口的对象。它实现了目标接口，并包含一个源接口的实例，用于将目标接口的方法转换为源接口的方法。

#### 2.1.4 优点

* 将目标类与适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无需修改原来的代码。
* 增加了类的透明性和复用性。
* 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

#### 2.1.5 缺点

**类适配器模式的缺点如下：**

对于不支持多继承的语言，一次只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。

**对象适配器模式的缺点如下：**

置换适配者的方法不容易。

#### 2.1.6 使用场景

* 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
* 系统需要使用现有的类，而这些类的接口不符合系统的需要。

### 2.2 桥接模式

#### 2.2.1 模式定义

抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。例如把品牌和电脑分离，使其组合。

#### 2.2.2 模式结构

* 抽象类
* 扩充抽象类
* 实现类接口
* 具体实现类

#### 2.2.3 模式分析

* 抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。
* 实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。
* 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。

#### 2.2.4 优点

* 分离抽象接口及其实现部分。
* 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。
* 实现细节对客户透明，可以对用户隐藏实现细节。
* 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。

#### 2.2.5 缺点

* 桥接模式的引入会增加系统的理解与设计难度。

#### 2.2.6 使用场景

* 当一个系统需要在多个维度上变化时，可以使用桥接模式将这些维度分离，使它们可以独立地变化。
* 当一个系统需要在抽象部分和实现部分之间添加更多的灵活性时，可以使用桥接模式。
* 当一个系统需要在运行时动态地选择一个实现部分时，可以使用桥接模式。
* 当一个系统需要将一个类分解为多个独立的层次结构时，可以使用桥接模式。
* 当一个系统需要在实现部分和抽象部分之间建立一个稳定的关联关系时，可以使用桥接模式。

### 2.3 装饰器模式

#### 2.3.1 模式定义

动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。

#### 2.3.2 模式结构

* 抽象构件
* 具体构件
* 抽象装饰类
* 具体装饰类

#### 2.3.3 模式分析

* 与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，继承的耦合度过高，无法在运行时动态扩展。关联关系的缺点是需要创建更多的对象。
* 使用装饰器模式可以更加灵活，他以对客户透明的方式动态给对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将功能进行扩展

#### 2.3.4 优点

* 装饰和继承都可以扩展对象的功能，但是装饰器更加灵活。
* 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，实现不同的功能。
* 使用不同的具体装饰类进行排列组合，可以得到不同的增强效果。
* 具体构件和装饰类可以单独变化，用户可以根据需要添加新的具体构件类和具体装饰类，在使用时再对其组合，原代码无需改变。

#### 2.3.5 缺点

* 小对象过多，他们的连接方式也有所不同，会产生很多具体装饰类，造成系统变得复杂。
* 灵活也就更加可能出错误，需要更多时间来逐级排查。

#### 2.3.6 使用场景

1. 在不影响其他类的情况下，动态透明的给单对象添加职责。
2. 需要动态的给一个对象添加功能，这些功能也可以动态地撤销。
3. 不能采用继承或者继承不利于系统的时候。

### 2.4 外观模式

#### 2.4.1 模式定义

外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

#### 2.4.2 模式结构

* 外观角色
* 子系统角色

#### 2.4.3 优点

1.  简化了客户端与子系统之间的交互：客户端不需要直接与子系统交互，而是通过外观类来间接地调用子系统的功能，从而降低了客户端与子系统之间的耦合度。
2. 提高了系统的可维护性：由于客户端与子系统之间的耦合度降低了，因此系统的可维护性也得到了提高。
3. 提高了系统的灵活性和可扩展性：由于外观类提供了一个简单的接口，因此可以在不影响客户端的情况下，对子系统进行修改、扩展或替换。

#### 2.4.4 缺点

1. 不能很好地支持高度个性化的需求：由于外观模式是为了简化系统的复杂性而设计的，因此如果系统中存在高度个性化的需求，那么外观模式可能不太适合。
2. 可能会引入额外的性能开销：由于外观模式需要增加一个外观类来封装子系统的复杂性，因此可能会引入额外的性能开销。

#### 2.4.5 使用场景

1. 当系统中存在复杂的子系统，且客户端需要使用这些子系统的功能时，可以考虑使用外观模式来简化客户端与子系统之间的交互。
2.  当需要对系统进行重构或者扩展时，可以考虑使用外观模式来降低重构或扩展的难度。
3. 当需要将系统的复杂性隐藏起来，提高系统的可维护性和可扩展性时，可以考虑使用外观模式。

### 2.5 享元模式

#### 2.5.1 模式定义

运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。

#### 2.5.2 模式结构

* 抽象享元类
* 具体享元类
* 非共享具体享元类
* 享元工厂类

#### 2.5.3 优点

1. 大大减少对象的创建，降低系统的内存，使效率提高。、
2. 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

#### 2.5.4 缺点

1. 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
2. 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。

#### 2.5.5 使用场景

1. 系统中有大量对象。
2.  这些对象消耗大量内存。
3. 这些对象的状态大部分可以外部化。
4. 系统不依赖于这些对象身份，这些对象是不可分辨的。

### 2.6 代理模式

#### 2.6.1 模式定义

给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。

#### 2.6.2 模式结构

* 抽象主题角色
* 代理主题角色
* 真实主题角色

#### 2.6.3 优点

1. 能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度
2. 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
3. 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。
4. 保护代理可以控制对真实对象的使用权限。

#### 2.6.4 缺点

1. 客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。
2. 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。

#### 2.6.5 使用场景

1. 远程代理
2. 虚拟代理
3. Copy-on-Write 代理
4. 保护（Protect or Access）代理
5. Cache代理
6. 防火墙（Firewall）代理
7. 同步化（Synchronization）代理
8. 智能引用（Smart Reference）代理。

